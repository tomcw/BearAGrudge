;ACME 0.97

!cpu 6502	; Compatible with all Apple2's
!to "bearagrudge", plain
!sl "bearagrudge.labels"
*=$6000

;------------------------------------------------------------------------------

!source "AppleDefs.a"
!source "MockingboardDefs.a"
!source "MB-Macros.a"

;------------------------------------------------------------------------------

pAYPattern = $f7
pAYPatternL = pAYPattern
pAYPatternH = $f8
TmpL    = $f9	; alias with pAYData
pAYData = $f9
pAYDataL = pAYData
pAYDataH = pAYData+1
MBBase	= $fb
MBBaseL	= MBBase
MBBaseH	= MBBase+1

zpTmp	= $fe	; use from user-land (also used by exod_decrunch - so can't use from IRQ handler)
zpTmpL	= zpTmp
zpTmpH	= zpTmp+1

!zone code

;--------------------------------------

INIT:
	lda		pAYPatternL
	sta		saveF7
	lda		pAYPatternH
	sta		saveF8
	lda		pAYData+0
	sta		saveF9
	lda		pAYData+1
	sta		saveFA
	lda		MBBaseL
	sta		saveFB
	lda		MBBaseH
	sta		saveFC

	lda		$9e
	sta		save9E
	lda		$9f
	sta		save9F
	lda		$a7
	sta		saveA7
	lda		$a8
	sta		saveA8
	lda		$ae
	sta		saveAE
	lda		$af
	sta		saveAF
	lda		$fd
	sta		saveFD
	lda		$fe
	sta		saveFE
	lda		$ff
	sta		saveFF

	;

	jsr		SF_GetMBSlot
	bne		GotMBSlot

		; MB not found!
		brk

GotMBSlot:
	stx		nMBBaseHi

	stx		MB1+2
	stx		MB2+2
	stx		MB3+2
	stx		MB4+2
	stx		MB5+2
	stx		MB6+2

	stx		MB1x+2
	stx		MB2x+2
	stx		MB3x+2
	stx		MB4x+2
	stx		MB5x+2
	stx		MB6x+2

	stx		MB1y+2
	stx		MB2y+2
	stx		MB3y+2
	stx		MB4y+2
	stx		MB5y+2
	stx		MB6y+2

	stx		MB7+2

	;

	lda		#$07
	ldy		#SY6522_DDRB
	sta		(MBBase),y
	ldy		#SY6522_DDRB+SY6522_B_BASE
	sta		(MBBase),y

	lda		#$ff
	ldy		#SY6522_DDRA
	sta		(MBBase),y
	ldy		#SY6522_DDRA+SY6522_B_BASE
	sta		(MBBase),y

	lda		#AY_RESET
	ldy		#SY6522_ORB
	sta		(MBBase),y
	ldy		#SY6522_ORB+SY6522_B_BASE
	sta		(MBBase),y

	;

	; pAYPatternL/H - is used by both userland & irq, but it's setup just once (here) and remains constant
	; It's referenced via variables: AYPatternIdx_user & AYPatternIdx_irq
	lda		#<AYPattern
	sta		pAYPatternL
	lda		#>AYPattern
	sta		pAYPatternH

	jsr		ResetAYPattern

	lda		#$20
	sta		NextAYChunkAddr_H_user
	sta		NextAYChunkAddr_H_irq

	jsr		DecrunchNext

	lda		#S_DECRUNCH_NEXT
	sta		State					; signal to main-loop to decrunch a 2nd chunk

	;

	; Setup Timer1 IRQ to trigger at 50Hz
	; Apple CLK = 1.022727 MHz, so set Timer1=0x4fe7

	sei

	lda		#$e7
	ldy		#SY6522_TIMER1L_COUNTER
	sta		(MBBase),y
	lda		#$4f
	ldy		#SY6522_TIMER1H_COUNTER
	sta		(MBBase),y

	lda		#ACR_FREERUNNING
	ldy		#SY6522_ACR
	sta		(MBBase),y				; Free running timer

	lda		#IER_SET|IxR_TIMER1
	ldy		#SY6522_IER	
	sta		(MBBase),y				; Enable Timer1 IRQ

	lda		#<Interrupt				; ADDR_L
	sta		IRQL
	lda		#>Interrupt				; ADDR_H 
	sta		IRQH

	jsr		NextAYChunk

	lda		#0
	sta		nFrameNum+0
	sta		nFrameNum+1
	sta		nFrameNum+2
	sta		g_MusicUpdate
	sta		g_PauseEnabled
	lda		#3
	sta		g_AYSelect

	cli

loop	lda		State
		beq		+	; S_NO_WORK
					; else: S_DECRUNCH_NEXT
			; Decrunch take ~28 frames, and each uncompressed chunk takes 1023*2 frames to playback (since BearAGrudge plays back at 25Hz)
			jsr		DecrunchNext
			lda		#S_NO_WORK
			sta		State
+		lda		BUTTON0
		and		BUTTON1
		and		#$80
		beq		+
			sta		g_PauseEnabled	; press OA+CA keys to enable

+		lda		KBD
		bpl		loop
		bit		KBDSTRB

		cmp		#27+$80				; ESC to quit
		beq		done

		cmp		#'1'+$80			; toggle 1st AY
		bne		+
			lda		#1
			bne		++
+		cmp		#'2'+$80			; toggle 2nd AY
		bne		+
			lda		#2
++			eor		g_AYSelect
			sta		g_AYSelect
			jmp		loop
+

pause	; step via one-shot mode
		lda		g_PauseEnabled		; NB. Pause is off by default
		beq		loop

		sei
		lda		#ACR_ONESHOT
		ldy		#SY6522_ACR
		sta		(MBBase),y
		lda		nFrameNum+2
		cli
-			cmp		nFrameNum+2
			beq		-

		ldy		nFrameNum+1			; Second
		ldx		nFrameNum+2			; Frame#
		jsr		PRNTYX
-			lda		KBD
			bpl		-
		bit		KBDSTRB
		tax		; keycode

		lda		#$e7
		ldy		#SY6522_TIMER1L_COUNTER
		sta		(MBBase),y
		lda		#$4f
		ldy		#SY6522_TIMER1H_COUNTER
		sta		(MBBase),y

		cpx		#' '+$80
		beq		pause

		; restart
		lda		#ACR_FREERUNNING
		ldy		#SY6522_ACR
		sta		(MBBase),y				; Free running timer
		jmp		loop

done
	sei
		lda		#AY_RESET
		ldy		#SY6522_ORB
		sta		(MBBase),y
		ldy		#SY6522_ORB+SY6522_B_BASE
		sta		(MBBase),y

		lda		#ACR_ONESHOT
		ldy		#SY6522_ACR
		sta		(MBBase),y

		ldy		#SY6522_IFR
-			lda		(MBBase),y
			and		#IxR_TIMER1
			beq		-

		lda		#IER_CLR|IxR_TIMER1
		ldy		#SY6522_IER
		sta		(MBBase),y				; Disable Timer1 IRQ
	cli

	lda		save9E
	sta		$9e
	lda		save9F
	sta		$9f
	lda		saveA7
	sta		$a7
	lda		saveA8
	sta		$a8
	lda		saveAE
	sta		$ae
	lda		saveAF
	sta		$af
	lda		saveFD
	sta		$fd
	lda		saveFE
	sta		$fe
	lda		saveFF
	sta		$ff

	lda		saveF7
	sta		pAYPatternL
	lda		saveF8
	sta		pAYPatternH
	lda		saveF9
	sta		pAYData+0
	lda		saveFA
	sta		pAYData+1
	lda		saveFB
	sta		MBBaseL
	lda		saveFC
	sta		MBBaseH

	rts

;--------------------------------------

ResetAYPattern
	lda		#0
	sta		AYPatternIdx
	rts

;--------------------------------------

; Called from user-land
DecrunchNext

	; Check for $00,$00 = end of pattern
	ldy		AYPatternIdx
	lda		(pAYPattern),y
	iny
	ora		(pAYPattern),y
	bne		+
		jsr		ResetAYPattern
+

	;
	; At the end of the compressed chunk, set the correct endAddress_h to decrunch to (decrunch occurs backwards)
	; . With an odd number of compressed chunks, then for each loop of the tune, chunks will alternate decrunching to $2000 or $4000
	;   eg. 1st time, chunk0 will decrunch to $2000; 2nd time it'll decrunch to $4000, etc

	ldy		AYPatternIdx

	lda		(pAYPattern),y		; lo(compressedAYxEnd)
	sta		zpTmpL
	iny
	lda		(pAYPattern),y		; hi(compressedAYxEnd)
	sta		zpTmpH

	ldy		#0
	lda		(zpTmp),y				; endAddr_h
	and		#$1f					; clr old $20 or $40
	ora		NextAYChunkAddr_H_user	; set new $20 or $40
	sta		(zpTmp),y

	lda		NextAYChunkAddr_H_user
	eor		#$60				; toggle: $20->$40 / $40->$20
	sta		NextAYChunkAddr_H_user

	;

	ldy		AYPatternIdx

	clc
	lda		(pAYPattern),y		; lo(compressedAYxEnd)
	adc		#COMPRESSED_CHUNK_END_ADJUST
	sta		_byte_lo
	iny

	lda		(pAYPattern),y		; hi(compressedAYxEnd)
	adc		#0
	sta		_byte_hi
	iny

	sty		AYPatternIdx

	;

	cld
	jsr		exod_decrunch		; NB. 0x8DEA6 cycles for chunk0

	rts

;--------------------------------------

; Called from IRQ handler
NextAYChunk

	lda		#0
	sta		pAYDataL

	lda		NextAYChunkAddr_H_irq
	sta		pAYDataH

	eor		#$60				; toggle: $20->$40 / $40->$20
	sta		NextAYChunkAddr_H_irq

	rts

;--------------------------------------

Interrupt
; Pre:
;	6502 has pushed P
;	Apple ROM has stored A to $45 (not Apple //e ROM!)
;

	txa 
	pha
	tya
	pha

	jsr		lefe5

	;

	lda		g_MusicUpdate
	eor		#1
	sta		g_MusicUpdate
	bne		+
	jmp		.done
+

	;
	; Unpack the regs: 8 -> 11 bytes
	;

	ldy		#0
	lda		(pAYData),y
	ldx		#0
	sta		g_UnpackedRegs,x

	iny
	lda		(pAYData),y
	ldx		#2
	sta		g_UnpackedRegs,x

	iny
	lda		(pAYData),y
	ldx		#4
	sta		g_UnpackedRegs,x

	iny
	lda		(pAYData),y
	lsr
	lsr
	lsr
	lsr
	ldx		#1
	sta		g_UnpackedRegs,x
	lda		(pAYData),y
	and		#$0f
	ldx		#3
	sta		g_UnpackedRegs,x

	iny
	lda		(pAYData),y
	lsr
	lsr
	lsr
	lsr
	ldx		#5
	sta		g_UnpackedRegs,x
	lda		(pAYData),y
	and		#$0f
	ldx		#8
	sta		g_UnpackedRegs,x

	iny
	lda		(pAYData),y
	lsr
	lsr
	lsr
	lsr
	ldx		#9
	sta		g_UnpackedRegs,x
	lda		(pAYData),y
	and		#$0f
	ldx		#10
	sta		g_UnpackedRegs,x

	iny
	lda		(pAYData),y
	ldx		#6
	sta		g_UnpackedRegs,x

	iny
	lda		(pAYData),y
	ldx		#7
	sta		g_UnpackedRegs,x

	;

	ldx		#AY_INACTIVE

	;
	; AY#0
	;

	lda		g_AYSelect
	and		#1
	beq		muteAY0

	ldy		#0
.sf_loop0
MB1x		sty		CARD_BASE+SY6522_ORA
			lda		#AY_LATCH
MB2x		sta		CARD_BASE+SY6522_ORB
MB3x		stx		CARD_BASE+SY6522_ORB	; Set INACTIVE
			lda		g_UnpackedRegs,y
!if 1 {		; Noise Period: Convert ZX to MB
			cpy		#AY_NOISEPER
			bne		+
			and		#AY_NOISE_MASK
			cmp		#1
			beq		+
			lsr
+
}
MB4x		sta		CARD_BASE+SY6522_ORA
			lda		#AY_WRITE
MB5x		sta		CARD_BASE+SY6522_ORB
MB6x		stx		CARD_BASE+SY6522_ORB	; Set INACTIVE
			iny
			cpy		#AY_EFINE
			bne		.sf_loop0
	beq		+

muteAY0
	ldy		#SY6522_A_BASE
	lda		#AY_ENABLE
	jsr		SF_SelectReg
	lda		#AY_DIS_A|AY_DIS_B|AY_DIS_C
	jsr		SF_WriteReg

+

	;
	; AY#1
	;

	lda		g_AYSelect
	and		#2
	beq		muteAY1

	ldy		#0
.sf_loop1
MB1y		sty		CARD_BASE+SY6522_B_BASE+SY6522_ORA
			lda		#AY_LATCH
MB2y		sta		CARD_BASE+SY6522_B_BASE+SY6522_ORB
MB3y		stx		CARD_BASE+SY6522_B_BASE+SY6522_ORB	; Set INACTIVE
			lda		g_UnpackedRegs,y
!if 1 {		; Noise Period: Convert ZX to MB
			cpy		#AY_NOISEPER
			bne		+
			and		#AY_NOISE_MASK
			cmp		#1
			beq		+
			lsr
+
}
MB4y		sta		CARD_BASE+SY6522_B_BASE+SY6522_ORA
			lda		#AY_WRITE
MB5y		sta		CARD_BASE+SY6522_B_BASE+SY6522_ORB
MB6y		stx		CARD_BASE+SY6522_B_BASE+SY6522_ORB	; Set INACTIVE
			iny
			cpy		#AY_EFINE
			bne		.sf_loop1

	beq		+

muteAY1
	ldy		#SY6522_B_BASE
	lda		#AY_ENABLE
	jsr		SF_SelectReg
	lda		#AY_DIS_A|AY_DIS_B|AY_DIS_C
	jsr		SF_WriteReg

+

	;

	clc
	lda		pAYData+0
	adc		#8						; AY regs packed into 8-byte sets
	sta		pAYData+0
	lda		pAYData+1
	adc		#0
	sta		pAYData+1

	; $ff,$ff = end of data
	ldy		#0
	lda		(pAYData),y
	iny
	and		(pAYData),y
	cmp		#$ff
	bne		+
		jsr		NextAYChunk
		lda		#S_DECRUNCH_NEXT
		sta		State				; signal to main-loop to decrunch next chunk
+

	;

.done
	lda		#IER_CLR|IxR_TIMER1
MB7	sta		CARD_BASE+SY6522_IFR	; Clear Timer1 IRQ flag

	pla
	tay
	pla
	tax

	lda		$45
	rti


;--------------------------------------

SF_SelectReg	; Select AY reg
MB1		sta		CARD_BASE+SY6522_ORA,y
		lda		#AY_LATCH
MB2		sta		CARD_BASE+SY6522_ORB,y
		lda		#AY_INACTIVE
MB3		sta		CARD_BASE+SY6522_ORB,y	; Set INACTIVE
		rts

SF_WriteReg		; Write AY reg
MB4		sta		CARD_BASE+SY6522_ORA,y
		lda		#AY_WRITE
MB5		sta		CARD_BASE+SY6522_ORB,y
		lda		#AY_INACTIVE
MB6		sta		CARD_BASE+SY6522_ORB,y	; Set INACTIVE
		rts

;--------------------------------------

lefe5:
	inc		nFrameNum+2
	lda		nFrameNum+2
	cmp		#50
	bne		.fnum_ok
		lda		#0
		sta		nFrameNum+2
		inc		nFrameNum+1
		lda		nFrameNum+1
		cmp		#60
		bne		.fnum_ok
			lda		#0
			sta		nFrameNum+1
			inc		nFrameNum+0
.fnum_ok:

	rts

;------------------------------------------------------------------------------

; Skyfox MB detection routine:

SF_GetMBSlot:
; Pre:
; Post:
;  Z = 0 (NE) : MB detected
;  X = HI(MB base address)
;  (MBBase) = MB slot address
;

	jsr		SF_Detect

.Loop:	stx		TmpL
		jsr		SF_Detect
		cpx		TmpL
		bne		.Loop

	cpx		#$C8
	rts

;--------------------------------------

SF_Detect:
	lda		#0
	sta		MBBaseL
	lda		#$c1
	sta		MBBaseH
	ldx		#7

.SlotNext:
		ldy		#$00+SY6522_TIMER1L_COUNTER
		jsr		SF_GetTimerL
		bne		.SlotLoop

		ldy		#$80+SY6522_TIMER1L_COUNTER
		jsr		SF_GetTimerL
		beq		.SlotDone

.SlotLoop:
		inc		MBBaseH
		dex
		bne		.SlotNext

.SlotDone:
	ldx		MBBaseH
	rts

;--------------------------------------


SF_GetTimerL:
	lda		(MBBase),y
	cmp		MBBaseL
	sbc		(MBBase),y
	cmp		#$08
	rts

;------------------------------------------------------------------------------

!zone data

nMBBaseHi		!byte 0
nFrameNum		!byte 0,0,0	; Minute:Second:FrameNum (@ 50Hz)
g_MusicUpdate	!byte 0
g_AYSelect		!byte 3		; bit1=AY#1, bit0=AY#0
g_PauseEnabled	!byte 0
AYPatternIdx	!byte 0
NextAYChunkAddr_H_user	!byte 0
NextAYChunkAddr_H_irq	!byte 0

S_NO_WORK = 0
S_DECRUNCH_NEXT = 1
State			!byte S_NO_WORK

g_UnpackedRegs	!fill 11,0

saveF7			!byte 0
saveF8			!byte 0
saveF9			!byte 0
saveFA			!byte 0
saveFB			!byte 0
saveFC			!byte 0

; exomizer
save9E			!byte 0
save9F			!byte 0
saveA7			!byte 0
saveA8			!byte 0
saveAE			!byte 0
saveAF			!byte 0
saveFD			!byte 0
saveFE			!byte 0
saveFF			!byte 0

;--------------------------------------

DECRUNCH_FORWARDS = 0

exod_get_crunched_byte:
!if DECRUNCH_FORWARDS = 0 {
        lda _byte_lo
        bne _byte_skip_hi
        dec _byte_hi
_byte_skip_hi:
        dec _byte_lo
}
_byte_lo = * + 1
_byte_hi = * + 2
        lda $ffff               ; needs to be set correctly before
!if DECRUNCH_FORWARDS != 0 {
        inc _byte_lo
        bne _byte_skip_hi
        inc _byte_hi
_byte_skip_hi:
}
        rts                     ; decrunch_file is called.
; end_of_data needs to point to the address just after the address
; of the last byte of crunched data.
; -------------------------------------
!source "exodecrunch.asm"

;--------------------------------------

USE_CHUNKS_WITH_APPLEII_PERIODS = 1

AYDataCompressed
!if USE_CHUNKS_WITH_APPLEII_PERIODS {
	!binary "ChunksWithAppleIIPeriods-Packed\\bearagrudge-AY0-comp.bin"
	compressedAY0End = *
	!binary "ChunksWithAppleIIPeriods-Packed\\bearagrudge-AY1-comp.bin"
	compressedAY1End = *
	!binary "ChunksWithAppleIIPeriods-Packed\\bearagrudge-AY2-comp.bin"
	compressedAY2End = *
	!binary "ChunksWithAppleIIPeriods-Packed\\bearagrudge-AY3-comp.bin"
	compressedAY3End = *
	!binary "ChunksWithAppleIIPeriods-Packed\\bearagrudge-AY4-comp.bin"
	compressedAY4End = *
} else {
	!binary "ChunksWithSpectrum128Periods-Packed\\bearagrudge-AY0-comp.bin"
	compressedAY0End = *
	!binary "ChunksWithSpectrum128Periods-Packed\\bearagrudge-AY1-comp.bin"
	compressedAY1End = *
	!binary "ChunksWithSpectrum128Periods-Packed\\bearagrudge-AY2-comp.bin"
	compressedAY2End = *
	!binary "ChunksWithSpectrum128Periods-Packed\\bearagrudge-AY3-comp.bin"
	compressedAY3End = *
	!binary "ChunksWithSpectrum128Periods-Packed\\bearagrudge-AY4-comp.bin"
	compressedAY4End = *
}

;--------------------------------------

; 5 chunks of $2000 bytes (except last one)
; Defaulting to $0000 dst addr for decompression - so needs fixing up
;
; An even number of chunks is ok to just loop
; - if odd number, then playback of last & decrunch of first will overlap!
; - so need to decompress to a non-default address (ie. overwrite last 2 bytes of compressed stream with new destination)

COMPRESSED_CHUNK_END_ADJUST = 1	; point at endAddr_h to decrunch to (NB. decrunch startAddr is always $0000)

AYPattern
	; AYPatternIdx
	!word compressedAY0End-COMPRESSED_CHUNK_END_ADJUST
	!word compressedAY1End-COMPRESSED_CHUNK_END_ADJUST
	!word compressedAY2End-COMPRESSED_CHUNK_END_ADJUST
	!word compressedAY3End-COMPRESSED_CHUNK_END_ADJUST
	!word compressedAY4End-COMPRESSED_CHUNK_END_ADJUST
	!word $0000								; loop
