;license:MIT
;(c) 2021-2022 by Tom Charlesworth
;
; AY8913 related
;

;------------------------------------------------------------------------------

DetectAY8913
; Pre: zpTmp1 = 6522 bitmap in b1:0
;	hasAY8913 = 0
;	isPhasorCard
; Post:
;	hasAY8913 = %0000,%0001,%0010,%0011 - for Mockingboard
;	hasAY8913 = %0011,%0111,%1011,%1111 - for Phasor (NB. only test for 2nd AYs if 1st AYs = %11)

	lda		zpTmp1
	sta		@smcPh+1

	lda		isPhasorCard
	beq		+
		lda		#PH_MOCKINGBOARD
		jsr		SetPhasorMode
+

!if 0 {		; comment out this mb-audit specific code
	lda		isMB4C
	ora		isEchoPlus
	beq		+
		lda		#%00000011
		sta		hasAY8913		; can't test them, so just assume they are all working
		rts
+
}

	lda		#SY6522_A_BASE
	sta		zpTmp3
	lda		#1					; hasAY8913 mask
	sta		zpTmp2

-		lsr		zpTmp1			; 6522 at this addr?
		bcc		+

		jsr		Init6522ForAY

		lda		#AY_AFINE
		ldx		#$AA
		jsr		AY_WriteRegValue

		lda		#AY_BFINE
		ldx		#$55
		jsr		AY_WriteRegValue

		lda		#AY_CFINE
		ldx		#$69
		jsr		AY_WriteRegValue

		;

		ldx		#AY_AFINE
		jsr		AY_ReadRegValue
		cmp		#$AA
		bne		+

		ldx		#AY_BFINE
		jsr		AY_ReadRegValue
		cmp		#$55
		bne		+

		ldx		#AY_CFINE
		jsr		AY_ReadRegValue
		cmp		#$69
		bne		+

			lda		hasAY8913
			ora		zpTmp2
			sta		hasAY8913

+		asl		zpTmp2			; mask <<= 1
		lda		zpTmp3
		eor		#$80
		sta		zpTmp3
		bne		-

	lda		isPhasorCard
	beq		+
	lda		#%00000011
	cmp		hasAY8913
	bne		@ok

	;
	; Phasor: detect any 2nd-ary AYs
	;

@smcPh	lda		#0
	sta		zpTmp1

	lda		#PH_PHASOR
	jsr		SetPhasorMode

	lda		#SY6522_A_PH_BASE
	sta		zpTmp3				; 6522-A base addr *for Phasor*
	lda		#%00000100			; hasAY8913 mask
	sta		zpTmp2

-		lsr		zpTmp1			; 6522 at this addr?
		bcc		+

		jsr		Init6522ForAY

		lda		#AY_AFINE
		ldx		#$AA
		jsr		AY2_WriteRegValue

		lda		#AY_BFINE
		ldx		#$55
		jsr		AY2_WriteRegValue

		lda		#AY_CFINE
		ldx		#$69
		jsr		AY2_WriteRegValue

		;

		ldx		#AY_AFINE
		jsr		AY2_ReadRegValue
		cmp		#$AA
		bne		+

		ldx		#AY_BFINE
		jsr		AY2_ReadRegValue
		cmp		#$55
		bne		+

		ldx		#AY_CFINE
		jsr		AY2_ReadRegValue
		cmp		#$69
		bne		+

			lda		hasAY8913
			ora		zpTmp2
			sta		hasAY8913

+		asl		zpTmp2			; mask <<= 1
		lda		#SY6522_B_BASE
		cmp		zpTmp3
		beq		+
		sta		zpTmp3
		bne		-

+	lda		#PH_MOCKINGBOARD
	jsr		SetPhasorMode

	;

@ok	rts

;------------------------------------------------------------------------------

Init6522ForAY
; Pre: phasorMode
;	zpTmp3 = SY6522_A_BASE or SY6522_A_PH_BASE or SY6522_B_BASE
; Post: Y = SY6522_ORA for chip A or B

	lda		#SY6522_DDRB
	ora		zpTmp3
	tay
	lda		phasorMode
	cmp		#PH_PHASOR
	beq		+
		lda		#$07
		bne		++
+		lda		#$1f
++	sta		(MBBase),y

	lda		#SY6522_DDRA
	ora		zpTmp3
	tay
	lda		#$ff	; output
	sta		(MBBase),y

	ldy		zpTmp3
	jmp		SF_ChipReset		; Post: Y=SY6522_ORA for chip A or B

	;

AY_WriteRegValue
; Pre: Y = SY6522_ORA for chip A or B
;	A=reg#
;	X=value
; Post: Y = SY6522_ORA for chip A or B
	jsr		SF_SelectReg
	txa
	jmp		SF_WriteReg

AY_ReadRegValue
; Pre: Y = SY6522_ORA for chip A or B
;	X=reg#
; Post: Y = SY6522_ORA for chip A or B
;	A=value
	jsr		AY_SetPortAOutput
	txa
	jsr		SF_SelectReg
	jsr		AY_SetPortAInput
	jmp		AY_ReadReg

	;

AY_SetPortAOutput
; Pre: Y = SY6522_ORA for chip A or B
; Post: Y = SY6522_ORA for chip A or B
	iny
	iny		; Y = DDRA
	lda		#$ff
	sta		(MBBase),y
	dey
	dey		; Y = ORA
	rts

AY_SetPortAInput
; Pre: Y = SY6522_ORA for chip A or B
; Post: Y = SY6522_ORA for chip A or B
	iny
	iny		; Y = DDRA
	lda		#$0
	sta		(MBBase),y
	dey
	dey		; Y = ORA
	rts

	;

AY_ReadReg
; Pre: Y = SY6522_ORA for chip A or B
;	6522.DDRA = $00 (Port-A direction = input)
; Post: Y = SY6522_ORA for chip A or B
;	A = data
	lda		#AY_READ
	dey		; Y = ORB (reg#0)
	sta		(MBBase),y
	iny		; Y = ORA (reg#1)
	lda		(MBBase),y		; Read Port-A
	tax
	lda		#AY_INACTIVE
	dey		; Y = ORB (reg#0)
	sta		(MBBase),y
	iny		; Y = ORA (reg#1)
	txa
	rts

SF_SelectReg
; Pre: Y = SY6522_ORA for chip A or B
;	A = reg#
; Post: Y = SY6522_ORA for chip A or B
	sta		(MBBase),y
	lda		#AY_LATCH
	bne		+

SF_WriteReg
; Pre: Y = SY6522_ORA for chip A or B
;	6522.DDRA = $FF (Port-A direction = output)
;	A = data
; Post: Y = SY6522_ORA for chip A or B
	sta		(MBBase),y
	lda		#AY_WRITE
	bne		+

SF_ChipReset
; NB. For native Phasor mode, reset both AY's, since cmd=AY_RESET|(%00<<3) - and CS is active low
; Pre: Y = SY6522_A_BASE or SY6522_B_BASE
; Post: Y = SY6522_ORA for chip A or B
	lda		#AY_RESET
	beq		++

+	dey		; Y = ORB (reg#0)

++	sta		(MBBase),y
	lda		#AY_INACTIVE
	sta		(MBBase),y
	iny		; Y = ORA (reg#1)
	rts

;------------------------------------------------------------------------------
; Phasor (native mode) routines:

!if 0 {
AY1_ReadReg
; Pre: Y = SY6522_ORA for chip A or B
;	6522.DDRA = $00 (Port-A direction = input)
; Post: Y = SY6522_ORA for chip A or B
;	A = data
	lda		#AY_READ|AY_CS1
	dey		; Y = ORB (reg#0)
	sta		(MBBase),y
	iny		; Y = ORA (reg#1)
	lda		(MBBase),y		; Read Port-A
	tax
	lda		#AY_INACTIVE|AY_CS1
	dey		; Y = ORB (reg#0)
	sta		(MBBase),y
	iny		; Y = ORA (reg#1)
	txa
	rts
}
AY2_ReadReg
	lda		#AY_READ|AY_CS2
	dey		; Y = ORB (reg#0)
	sta		(MBBase),y
	iny		; Y = ORA (reg#1)
	lda		(MBBase),y		; Read Port-A
	tax
	lda		#AY_INACTIVE|AY_CS2
	dey		; Y = ORB (reg#0)
	sta		(MBBase),y
	iny		; Y = ORA (reg#1)
	txa
	rts

AY1_SelectReg
; Pre: Y = SY6522_ORA for chip A or B
;	A = reg#
; Post: Y = SY6522_ORA for chip A or B
	sta		(MBBase),y
	lda		#AY_LATCH|AY_CS1
	bne		+
AY2_SelectReg
	sta		(MBBase),y
	lda		#AY_LATCH|AY_CS2
	bne		++

AY1_WriteReg
; Pre: Y = SY6522_ORA for chip A or B
;	6522.DDRA = $FF (Port-A direction = output)
;	A = data
; Post: Y = SY6522_ORA for chip A or B
	sta		(MBBase),y
	lda		#AY_WRITE|AY_CS1
	bne		+
AY2_WriteReg
	sta		(MBBase),y
	lda		#AY_WRITE|AY_CS2
	bne		++

+	dey		; Y = ORB (reg#0)
	sta		(MBBase),y
	lda		#AY_INACTIVE|AY_CS1
	sta		(MBBase),y
	iny		; Y = ORA (reg#1)
	rts

++	dey		; Y = ORB (reg#0)
	sta		(MBBase),y
	lda		#AY_INACTIVE|AY_CS2
	sta		(MBBase),y
	iny		; Y = ORA (reg#1)
	rts

;------------------------------------------------------------------------------

AY1_WriteRegValue
; Pre: Y = SY6522_ORA for chip A or B
;	A=reg#
;	X=value
	jsr		AY1_SelectReg
	txa
	jmp		AY1_WriteReg

AY2_WriteRegValue
; Pre: Y = SY6522_ORA for chip A or B
;	A=reg#
;	X=value
	jsr		AY2_SelectReg
	txa
	jmp		AY2_WriteReg

!if 0 {
AY1_ReadRegValue
; Pre: Y = SY6522_ORA for chip A or B
;	X=reg#
; Post:
;	A=value
	jsr		AY_SetPortAOutput
	txa
	jsr		AY1_SelectReg
	jsr		AY_SetPortAInput
	jmp		AY1_ReadReg
}

AY2_ReadRegValue
; Pre: Y = SY6522_ORA for chip A or B
;	X=reg#
; Post:
;	A=value
	jsr		AY_SetPortAOutput
	txa
	jsr		AY2_SelectReg
	jsr		AY_SetPortAInput
	jmp		AY2_ReadReg
